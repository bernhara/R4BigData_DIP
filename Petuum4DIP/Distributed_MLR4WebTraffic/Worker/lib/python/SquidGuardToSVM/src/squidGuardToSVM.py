#! /usr/bin/env python3

# coding: utf-8 

# TdB
import os
import sys
import hashlib

import argparse

import unittest

import logging
logging.basicConfig (level=logging.WARNING)

#
# Globals
#

_squidGuardCategories = []
_feature_one_based = False
_label_one_based = False
_feature_dim = -1
_squidguard_dummy_line = 'squidguard_client_ip_addr=192.168.1.1&squidguard_domain_name=&squidguard_client_user_id=&squidguard_client_group=default&squidguard_target_group=none&squidguard_url=http://dummy 192.168.1.1/- - -'
_squidguard_target_group_field_name = 'squidguard_target_group'


def hashStringToLibSVMValue (string_to_encode):
    
    string_to_encode_utf8 = string_to_encode.encode('utf8')
    md5_holder = hashlib.md5(string_to_encode_utf8)
    md5_hash_value_byte_array = md5_holder.digest()
    
    md5_hash_value_converted_to_decimals = ''.join ('{0:03d}'.format (single_byte) for single_byte in md5_hash_value_byte_array)
    
    md5_hash_as_float_string = '0.' + md5_hash_value_converted_to_decimals
    
    return (md5_hash_as_float_string)
    
   


def buildCategoryTable (squidGuardConfigurationFileName):
    
    global _squidGuardCategories
    
    # 'none' is a predefined category
    _squidGuardCategories = ['none']
        
    with open (squidGuardConfigurationFileName) as squidGuardConfigurationFile:
        for line in squidGuardConfigurationFile:
            splitted_line = line.split(maxsplit=3)
            if len (splitted_line) == 3:
                if splitted_line[0] == 'dest':
                    category = splitted_line[1]
                    _squidGuardCategories.append(category)
                    
                    
def dumpCategoryTable (categoriesDumpFileName):
    
    global _squidGuardCategories
    global _label_one_based
    
    if _label_one_based:
        startIndex = 1
    else:
        startIndex = 0
    
    with open (categoriesDumpFileName, 'w') as categoriesDumpFile:
        
        for indexed_category in enumerate (_squidGuardCategories, start=startIndex):
            print ('{} {}'.format(indexed_category[0], indexed_category[1]), file = categoriesDumpFile)
  


httpMethodsList = [
    'GET',
    'HEAD',
    'POST',
    'PUT',
    'DELETE',
    'CONNECT',
    'OPTIONS',
    'TRACE'
]

def read_libsvm_file(data_file_name):
    """
    svm_read_problem(data_file_name) -> [y, x]

    Read LIBSVM-format data from data_file_name and return labels y
    and data instances x.
    """
    prob_y = []
    prob_x = []
    for line in open(data_file_name):
        line = line.split(None, 1)
        # In case an instance with all zero features
        if len(line) == 1: line += ['']
        label, features = line
        xi = {}
        for e in features.split():
            ind, val = e.split(":")
            xi[int(ind)] = float(val)
        prob_y += [float(label)]
        prob_x += [xi]
    return (prob_y, prob_x)

_access_log_field_names = [
    'time',
    'delay',
    'source_host',
    'squid_cache_result',
    'what1',
    'http_method',
    'full_url',
    'what2',
    'destination_method_and_host',
    'mime_type'
]


def analyzeSingleLogLine (squidguardLine, squidAccesLogLine):
    
    #
    # analyze squidGuard input line to check if it is correct and does not lead to a crash later on
    #
    # Possible currently known formats are:
    #     OK rewrite-url="squidguard_client_ip_addr=192.168.1.15&squidguard_domain_name=&squidguard_client_user_id=&squidguard_client_group=default&squidguard_target_group=tracker&squidguard_url=http://b.scorecardresearch.com/p2?"
    #     rewrite-url="squidguard_client_ip_addr=192.168.1.15&squidguard_domain_name=&squidguard_client_user_id=&squidguard_client_group=default&squidguard_target_group=tracker&squidguard_url=http://b.scorecardresearch.com/p2?"
    
    
    # elements are separated by ' '
    squidguardLine_elements_list = squidguardLine.split(' ')
    
    # search the element containing what is pointed by the _squidguard_target_group_field_name' variable 
    # to find out what has been generated by *OUR* squidGuard rewrite rule
    squidguardLine_rewrite_result = None
    for squidguardLine_element in squidguardLine_elements_list:
        # search for the field containing the 
        if squidguardLine_element.find(_squidguard_target_group_field_name) != -1:
            # found the expected content
            
            #
            # an evolution of squidGuard changed the string produced by squidGuard's rewrite rule
            # in that case, it takes the form
            #    OK rewrite-url="<content produced by previous version of squidGuard"
            #
            # We check if we encounter that case and extract the relevant content
            # from squidguardLine_rewrite_result which may indeed the form
            #    rewrite-url="<content produced by previous version of squidGuard"
            if squidguardLine_element.startswith('rewrite-url="'):
                # content is surrounded
                # extract the substring
                squidguardLine_rewrite_result=squidguardLine_element[12:-1]
            else: 
                squidguardLine_rewrite_result=squidguardLine_element
            
            # don't analyze further elements, since we found what we are searching for
            break

        
    if not squidguardLine_rewrite_result:
        # failed to find what we are searching for => unexpected
        logging.info ("no valid squidGuard resulting line found. Go on with a dummny line")
        logging.debug ("\tSquid access log line: %s" % squidAccesLogLine)
        logging.debug ("\tsquidGuard resulting line: %s" % squidguardLine)
        #
        # rebuild a dummy line to prevent later crash
        squidguardLine_rewrite_result = _squidguard_dummy_line
        

    
    
    
    web_request_analysis_dict = {}
    
    #
    # The symbol '&' found in squidguardLine_rewrite_result has two meanings, depending where it is placed
    # - it separates fields produced by *OUR* squidGuard's rewrite rule
    # - it separates the URL arguments of the initial URL provided in the Squid logs
    #
    # Since the URL is *ALSWAYS* located at the end of squidguardLine_rewrite_result,
    #  we isolate this *last* tag to treat it differently from the tags locate before the URL
    #
    # See the generated "squidGuard.conf" file to see how the rewrite string is generated
    # 
    #
    url_field_index_in_squidguard_line = squidguardLine_rewrite_result.find ('squidguard_url=')
        
    if url_field_index_in_squidguard_line != -1:
   
        # isolate and treat the part *BEFORE* URL
        squidguardLine_substring_before_url = squidguardLine_rewrite_result[:url_field_index_in_squidguard_line - 1]
        squidguard_tags_for_web_request_list = squidguardLine_substring_before_url.split('&')
        
        # isolate and treat the *LAST* tag which contains the URL
        squidguardLine_substring_containing_url = squidguardLine_rewrite_result[url_field_index_in_squidguard_line:]
        squidguard_tags_for_web_request_list.append(squidguardLine_substring_containing_url)
        
    else:
        # no "url' field found => no splitting problem
        # this shouls not happen if the file "squidGuard.cond" s well configured
        # but it does not prevent to work normally
        squidguard_tags_for_web_request_list = squidguardLine_rewrite_result.split('&')

    for squidguard_tag in squidguard_tags_for_web_request_list:
        tag_name_and_value_list = squidguard_tag.split ('=', maxsplit=1)
        if len(tag_name_and_value_list) !=2:
            # this tag is not well formated
            # skip it
            logger.error ("found a badly formated tag: %s" % squidguard_tag)
            continue
        
        tag_name, tag_value = tag_name_and_value_list
        web_request_analysis_dict[tag_name] = tag_value
    
    # analyse squidAccesslog input line
    squid_access_log_field_list = squidAccesLogLine.split()
    squid_access_log_field_list_len = len(squid_access_log_field_list)
    
    for index in range (squid_access_log_field_list_len):
        field_name = _access_log_field_names[index]
        field_value = squid_access_log_field_list[index]
        web_request_analysis_dict[field_name] = field_value
        
    return web_request_analysis_dict

def buildWebRequestToLibSVMLineFormater ():

    global _feature_on_based
    global _label_one_based    
    global _feature_dim
    
    # How the resulting line will be formated
    if _feature_one_based:
        first_feature_index = 1
    else:
        first_feature_index = 0
    
    # the squidGuard computed category(ie. label) index
    _libSvmFormat = '{label_index:2d}'
    
    # list of features
    
    # FIXME: this should be computed!
    _feature_dim = 10
    
    feature_index = first_feature_index
    
    _libSvmFormat += ' ' + str(feature_index) + ':{GET}'; feature_index += 1
    _libSvmFormat += ' ' + str(feature_index) + ':{HEAD}'; feature_index += 1
    _libSvmFormat += ' ' + str(feature_index) + ':{POST}'; feature_index += 1
    _libSvmFormat += ' ' + str(feature_index) + ':{PUT}'; feature_index += 1
    _libSvmFormat += ' ' + str(feature_index) + ':{DELETE}'; feature_index += 1
    _libSvmFormat += ' ' + str(feature_index) + ':{CONNECT}'; feature_index += 1
    _libSvmFormat += ' ' + str(feature_index) + ':{OPTIONS}'; feature_index += 1
    _libSvmFormat += ' ' + str(feature_index) + ':{TRACE}'; feature_index += 1
    _libSvmFormat += ' ' + str(feature_index) + ':{full_url}'; feature_index += 1
    _libSvmFormat += ' ' + str(feature_index) + ':{source_host}'; feature_index += 1
    
    return _libSvmFormat
        

def webRequestToLibSVMLine (web_request_analysis_dict, libSvmLineFormat):
    

    logging.debug ('squidGuard group: {}'.format(web_request_analysis_dict[_squidguard_target_group_field_name]))
    
    libSVMLineData = {}
    
    # the label
    category = web_request_analysis_dict[_squidguard_target_group_field_name]
    # get a "0 based" category index
    category_index = _squidGuardCategories.index(category)
    if _label_one_based:
        libSVMLineData['label_index'] = category_index + 1
    else:
        libSVMLineData['label_index'] = category_index
    
    # features
    
    # ... HTTP method
    http_method_used_in_request = web_request_analysis_dict['http_method']
    for m in httpMethodsList:
        if http_method_used_in_request == m:
            libSVMLineData[m] = 1
        else:
            libSVMLineData[m] = 0
     
    # ... URL
    url_in_request = web_request_analysis_dict['full_url']
    libsvm_encoded_url = hashStringToLibSVMValue(url_in_request)
    libSVMLineData['full_url'] = libsvm_encoded_url
    
    # ... source_host
    source_host_in_request = web_request_analysis_dict['source_host']
    libsvm_encoded_source_host = hashStringToLibSVMValue(source_host_in_request)
    libSVMLineData['source_host'] = libsvm_encoded_source_host    
    
    libsvm_formated_line = libSvmLineFormat.format(**libSVMLineData)
    return (libsvm_formated_line)
                
          
def squidGuardOutputFileToLibSVMInputFile (squidGuardFileName, squidAccessLogFileName, libSVMFileName):
    
    global _feature_on_based
    global _label_one_based
    global _feature_dim
    
    libSvmLineFormat = buildWebRequestToLibSVMLineFormater ()
    
    input_file_line_numbers = 0
    
    # load
    with open (squidGuardFileName, encoding = 'latin_1') as squidGuardOuputFile:
        with open (squidAccessLogFileName, encoding = 'latin_1') as squidAccessLogFile:
            with open (libSVMFileName, 'w') as libSVMFile:
                while True:
                                
                    squidguardLine = squidGuardOuputFile.readline()
                    if not squidguardLine:
                        # enf of file
                        break
                    
                    input_file_line_numbers += 1
                    squidAccesLogLine = squidAccessLogFile.readline()
                    
                    web_request_analysis_dict = analyzeSingleLogLine (squidguardLine, squidAccesLogLine)
                    
                    logging.debug (web_request_analysis_dict)
                    libsvm_formated_line = webRequestToLibSVMLine (web_request_analysis_dict, libSvmLineFormat)
                    logging.debug (libsvm_formated_line)
                    print (libsvm_formated_line, file=libSVMFile)
    
    # generate "meta" file        
    libSVMMetaFileName = libSVMFileName + '.meta'
    
    num_train_total = input_file_line_numbers
    # TODO: test with one worker, input file not split
    num_train_this_partition = num_train_total
    # FIXME: test file size is currently not computed
    num_test = 1
    num_labels = len (_squidGuardCategories)
    
    if _feature_one_based:
        feature_one_based = 1
    else:
        feature_one_based = 0
    
    if _label_one_based:
        label_one_based = 1
    else:
        label_one_based = 0
          
    snappy_compressed = 0
    
    with open (libSVMMetaFileName, 'w') as libSVMMetaFile:
        print ('num_train_total: {}'.format (num_train_total), file=libSVMMetaFile)
        print ('num_train_this_partition: {}'.format (num_train_this_partition), file=libSVMMetaFile)
        print ('feature_dim: {}'.format (_feature_dim), file=libSVMMetaFile)
        print ('num_labels: {}'.format (num_labels), file=libSVMMetaFile)
        print ('format: libsvm', file=libSVMMetaFile)
        print ('feature_one_based: {}'.format (feature_one_based), file=libSVMMetaFile)        
        print ('label_one_based: {}'.format (label_one_based), file=libSVMMetaFile)
        print ('snappy_compressed: {}'.format (snappy_compressed), file=libSVMMetaFile)
        

def main():
    
    global _feature_one_based
    global _label_one_based
    
    parser = argparse.ArgumentParser(description='Generates a LIB SVM formated file for Squid Access Logs which have been labeled by squidGuard.')
    parser.add_argument("-s", "--squidAccessLogFile", metavar='<squid access log>', type=str, dest="squidAccessLogFile", required=True, 
                        help='The Squid access log file.')
    parser.add_argument("-g", "--squidGuardFile", metavar='<squidGuard out>', type=str, dest="squidGuardFile", required=True,
                        help='The resulting file after applying squidGuard to <squid access log>.')
    parser.add_argument("-p", "--libSVMFile", metavar='<libsvm for Petuum MLR>', type=str, dest="libSVMFile", required=True,
                        help='''The resulting "LIB SVM" formated file, containing the classified content.
    The additional file with "<libSVMFile>.meta" suffix is generated, which contains the information required by Petuum's MLR algorithm.
    These 2 files can be used as input to Petuum's MRL''')
    parser.add_argument("-c", "--squidGuardConf", metavar='<squidGuard configuration file>', type=str, dest="squidGuardConfigurationFile", required=True,
                        help='The squidGuard configuration file used to generate <squidGuard out>.')
    parser.add_argument("-k", "--categoriesDump", metavar='<category dump file>', type=str, dest="categoriesDumpFile", required=True,
                        help='Generated file, containing the list of all matched categories with their LibSVM index. Each category index is considered as a LibSVM label.')
    parser.add_argument("--featureOneBased", action='store_true', dest="featureOneBased", 
                        help='If true, feature indexes start at "1", "0" else (default is false => first feature index is "0"')
    parser.add_argument("--labelOneBased", action='store_true', dest="labelOneBased",
                        help='If true, labels indexes start at "1", "0" else (default is false => first label index is "0"')
    parser.add_argument("-d", "--debug", action='store_true', dest="debug")
    
    args = parser.parse_args()
    
    if args.featureOneBased:
        _feature_one_based = True
    else:
        _feature_one_based = False
        
    if args.labelOneBased:
        _label_one_based = True
    else:
        _label_one_based = False   
        
    if args.debug:
        logging.getLogger().setLevel (logging.DEBUG)
    

    buildCategoryTable (args.squidGuardConfigurationFile)
    dumpCategoryTable (args.categoriesDumpFile)
    
    squidAccessLogFileName = args.squidAccessLogFile
    squidGuardFileName = args.squidGuardFile
    libSVMFileName = args.libSVMFile
    squidGuardOutputFileToLibSVMInputFile (squidGuardFileName, squidAccessLogFileName, libSVMFileName)
    
#
# TEST CASES
# ==========

class moduleTestCases (unittest.TestCase):

    def test_analyzeSingleLogLine_v1 (self):
        
        squid_access_log_line = '''1495430914.656      1 192.168.1.24 TCP_MEM_HIT/200 4918 GET http://s3.amazonaws.com/anydo/prod/services.json - HIER_NONE/- application/octet-stream'''
        squidGuard_result_string = '''squidguard_client_ip_addr=-&squidguard_domain_name=&squidguard_client_user_id=&squidguard_client_group=default&squidguard_target_group=downloads&squidguard_url=http://s3.amazonaws.com/anydo/prod/services.json -/- - GET'''

        test_result = analyzeSingleLogLine(squidGuard_result_string, squid_access_log_line)
        
        expected_test_result = {'squidguard_client_ip_addr': '-', 'squidguard_domain_name': '', 'squidguard_client_user_id': '', 'squidguard_client_group': 'default', 'squidguard_target_group': 'downloads', 'squidguard_url': 'http://s3.amazonaws.com/anydo/prod/services.json', 'time': '1495430914.656', 'delay': '1', 'source_host': '192.168.1.24', 'squid_cache_result': 'TCP_MEM_HIT/200', 'what1': '4918', 'http_method': 'GET', 'full_url': 'http://s3.amazonaws.com/anydo/prod/services.json', 'what2': '-', 'destination_method_and_host': 'HIER_NONE/-', 'mime_type': 'application/octet-stream'}
        self.assertEqual(expected_test_result, test_result)    
        
    
    def test_analyzeSingleLogLine_v2 (self):
        
        squid_access_log_line = '''1495430914.656      1 192.168.1.24 TCP_MEM_HIT/200 4918 GET http://s3.amazonaws.com/anydo/prod/services.json - HIER_NONE/- application/octet-stream'''
        squidGuard_result_string = '''OK rewrite-url="squidguard_client_ip_addr=-&squidguard_domain_name=&squidguard_client_user_id=&squidguard_client_group=default&squidguard_target_group=downloads&squidguard_url=http://s3.amazonaws.com/anydo/prod/services.json"'''

        test_result = analyzeSingleLogLine(squidGuard_result_string, squid_access_log_line)
        
        expected_test_result = None
        self.assertEqual(expected_test_result, test_result)    
    

if __name__ == '__main__':
    main()
